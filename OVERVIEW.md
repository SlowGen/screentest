# Submission: Overview # 
## by: Kali Linn - kali@kali.nyc ##

### ğŸš€ [Deployed App](https://screentest-d8a5d.web.app/) ğŸš€   ||   ğŸ–¥ï¸ [GitHub Repo](https://github.com/SlowGen/screentest) ğŸ’» ###

ğŸŸ© I chose to use React with Redux to build this app. I have had previous experience with both and because I had a degree of lesser experience with drawing on the canvas, I felt it best to focus my learning engergies there. Using Redux gave more flexibility with adding features as I progressed and ensured a more seamless and responsive experience. The extra work in set-up paid off immensely in the end.

ğŸŸ£ I think the most interesting lesson to pass on from this experience was learning the intricacies of the mouse click events. Because canvas is itself a singular element on the DOM, and the drawings are merely instructions for how that element should appear, some otherwise useful event listeners are rendered useless. Thus it becomes necessary to build these out within the available event listeners. Specifically, drag. Learning the difference between 'onClick', and 'onMouseDown'/'onMouseUp' was critical and beneficial to accomplishing this. In this process, I noticed that very quick mouse movements can cause the triggers to misfire unexpectedly. I was able to accomplish this being unnoticeable to the user with single shapes, but with multiple shapes, rapid movement misfires were easy to reproduce and unavoidable. Without the help of a more in-depth library, I had to ultimately accept this edge case as outside the scope of this project.

ğŸŸ§ In addition to tweaking the sequences after the event triggers, I also implemented a mini "cache" system to prevent errors being thrown when a shape got temporarily lost in a misfire. This not only kept the app from crashing, but also increased performance slightly by eliminating the need to recalculate every single hit test every time.

ğŸ”´ Because this app was built with Redux, I think adding new features would be a relatively easy task. Mentally mapping out the suggested features (local Storage, undo/redo and save Image) would require very few additional lines of code. The details of these features are expanded upon [here](https://github.com/SlowGen/screentest/blob/main/PLAN_FOR_FEATURES.md)

ğŸŸ¦ Some potential performance bottlenecks could be due to having a very high volume of shapes being re-rendered on every update. This could be potentially mitigated by either using a batch system for re-draws and/or taking advantage of local storage to cache older parts of the image that have been "saved". Since canvases can be separately layered and rendered, the sections that have no current updates would not need to be re-rendered. Additionally, having too many images on a current working canvas makes it difficult to access under-layers. Potentially, an additional control panel with all images (not just selected) could be implemented for quicker access to these under-layers.